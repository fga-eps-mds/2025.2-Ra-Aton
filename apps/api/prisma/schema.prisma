generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enumerates

enum ProfileType {
  JOGADOR
  TORCEDOR
  ATLETICA
}

enum TeamSide {
  A
  B
}

enum GroupRole {
  ADMIN
  MEMBER
}

enum PostType {
  GENERAL
  EVENT
}

enum ReportStatus {
  PENDING
  REVIEWED
  DISMISSED
}

enum GroupType {
  ATHLETIC
  AMATEUR
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum MadeBy {
  USER
  GROUP
}


enum JoinRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum MatchStatus {
  EM_BREVE
  EM_ANDAMENTO
  FINALIZADO
}
enum NotificationType {
  GROUP_JOIN_REQUEST
  GROUP_JOIN_APPROVED
  GROUP_JOIN_REJECTED
  MATCH_REMINDER
  SYSTEM
}

// Models
model User {
  id           String       @id @default(uuid())
  name         String
  email        String       @unique
  userName     String       @unique
  profileType  ProfileType?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  passwordHash String

  // Relationships
  subscription PlayerSubscription[]
  posts           Post[]
  matchs          Match[]
  Attendance      Attendance[]
  Report          Report[]
  PostLike        PostLike[]
  Comment         Comment[]
  joinRequests    GroupJoinRequest[]
  GroupMembership GroupMembership[]
  followedGroups GroupFollow[]
  notifications Notification[]
}

model Post {
  id        String   @id @default(uuid())
  title     String
  content   String?
  type      PostType @default(GENERAL)
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String
  group     Group?   @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Event-specific fields (nullable for non-event posts)
  eventDate       DateTime? // data/hora do evento
  eventFinishDate DateTime? // opcional no frontend
  location        String? // local do evento

  // denormalized counters (optional, useful for real-time UI)
  likesCount       Int @default(0)
  commentsCount    Int @default(0)
  attendancesCount Int @default(0)

  // relations
  //attachments PostAttachment[]
  comments    Comment[]
  likes       PostLike[]
  reports     Report[]
  attendances Attendance[]
}

model Attendance {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  createdAt DateTime @default(now())

  @@unique([userId, postId])
}

// model PostAttachment {
//   id       String  @id @default(uuid())
//   post     Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
//   postId   String
//   url      String
//   mimeType String?
//   order    Int     @default(0)
// }

model Report {
  id         String       @id @default(uuid())
  reporter   User         @relation(fields: [reporterId], references: [id], onDelete: Cascade)
  reporterId String
  // report can reference either a post or a comment
  post       Post?        @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId     String?
  comment    Comment?     @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId  String?
  reason     String
  status     ReportStatus @default(PENDING)
  createdAt  DateTime     @default(now())
}

model PostLike {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  createdAt DateTime @default(now())

  @@unique([userId, postId])
}

model Comment {
  id        String   @id @default(uuid())
  content   String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  reports   Report[]

  @@index([postId, createdAt])
}

model Group {
  id          String    @id @default(uuid())
  name        String    @unique
  description String?
  sports      String[]
  groupType   GroupType @default(AMATEUR)

  acceptingNewMembers Boolean             @default(false)
  verificationRequest Boolean             @default(false)
  verificationStatus  VerificationStatus?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // relationsships
  joinRequests GroupJoinRequest[]
  posts        Post[]
  memberships  GroupMembership[]
  followers GroupFollow[]
}

model GroupMembership {
  id        String    @id @default(uuid())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  group     Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId   String
  role      GroupRole @default(MEMBER)
  isCreator Boolean   @default(false) // quem cria automaticamente ganha isCreator=true
  createdAt DateTime  @default(now())

  @@unique([userId, groupId])
}

// model Follow {
//   id        String   @id @default(uuid())
//   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
//   userId    String
//   group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
//   groupId   String
//   createdAt DateTime @default(now())

//   @@unique([userId, groupId])
// }

model GroupJoinRequest {
  id        String            @id @default(uuid())
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  group     Group             @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId   String
  madeBy    MadeBy
  status    JoinRequestStatus @default(PENDING)
  message   String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  @@unique([userId, groupId])
}

model Match {
  id          String               @id @default(uuid())
  title       String
  description String? // descrição (opcional)
  teamNameA   String?              @default("TIME_A") // nome do time A
  teamNameB   String?              @default("TIME_B") // nome do time B
  author      User                 @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String
  maxPlayers  Int // numero max de jogadores
  players     PlayerSubscription[] // jogadores inscritos
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  MatchDate   DateTime
  MatchStatus MatchStatus
  reminderSent Boolean @default(false)
  location    String
  sport       String
}

model PlayerSubscription {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  matchId   String
  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  team      TeamSide
  createdAt DateTime @default(now())

  @@unique([userId, matchId]) // garante que o usuário apenas se inscreva uma vez por partida
}

model GroupFollow {
  id String @id @default(uuid())

  userId String
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  groupId String
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, groupId])
}

model Notification {
  id String @id @default(uuid())
  userId String
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  title String
  content String
  type NotificationType

  resourceId String?
  resourceType String? // "GROUP", "MATCH"

  readAt DateTime?
  createdAt DateTime @default(now())
}