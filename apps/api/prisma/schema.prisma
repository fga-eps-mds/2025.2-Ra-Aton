generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enumerates

enum ProfileType {
  JOGADOR
  TORCEDOR
  ATLETICA
}

enum TeamSide {
  A
  B
}

enum GroupRole {
  ADMIN
  MEMBER
}

enum PostType {
  GENERAL
  EVENT
}

enum ReportStatus {
  PENDING
  REVIEWED
  DISMISSED
}

enum GroupType {
  ATHLETIC
  AMATEUR
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum MadeBy {
  USER
  GROUP
}

enum JoinRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

enum MatchStatus {
  EM_BREVE
  EM_ANDAMENTO
  FINALIZADO
}

enum NotificationType {
  GROUP_JOIN_REQUEST
  GROUP_JOIN_APPROVED
  GROUP_JOIN_REJECTED
  MATCH_REMINDER
  EVENT_REMINDER
  SYSTEM
}

// Models
model User {
  id                   String       @id @default(uuid())
  name                 String
  email                String       @unique
  userName             String       @unique
  profileType          ProfileType?
  createdAt            DateTime     @default(now())
  updatedAt            DateTime     @updatedAt
  passwordHash         String
  notificationsAllowed Boolean      @default(true)

  bio              String?  // Bio do usuário
  profileImageUrl  String?  // URL da imagem de perfil no Cloudinary
  bannerImageUrl   String?  // URL do banner no Cloudinary
  profileImageId   String?  // Public ID do Cloudinary (para deletar)
  bannerImageId    String?  // Public ID do Cloudinary (para deletar)

  // Relationships
  subscription    PlayerSubscription[]
  posts           Post[]
  matchs          Match[]
  Attendance      Attendance[]
  Report          Report[]
  PostLike        PostLike[]
  Comment         Comment[]
  joinRequests    GroupJoinRequest[]
  GroupMembership GroupMembership[]
  notifyTokens    UsersNotifyTokens[]
  followers       UserFollow[] @relation("UserFollowers")
  following       UserFollow[] @relation("UserFollowing")
  followedGroups  GroupFollow[]
  notifications   Notification[]
  avaliations     Avaliation[]
}

model Post {
  id        String   @id @default(uuid())
  title     String
  content   String?
  type      PostType @default(GENERAL)
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String
  group     Group?   @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Event-specific fields (nullable for non-event posts)
  eventDate       DateTime? // data/hora do evento
  eventFinishDate DateTime? // opcional no frontend
  location        String? // local do evento
  reminderSent Boolean @default(false)

  // denormalized counters (optional, useful for real-time UI)
  likesCount       Int @default(0)
  commentsCount    Int @default(0)
  attendancesCount Int @default(0)

  // relations
  //attachments PostAttachment[]
  comments    Comment[]
  likes       PostLike[]
  reports     Report[]
  attendances Attendance[]
}

model Attendance {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  createdAt DateTime @default(now())

  @@unique([userId, postId])
}

// model PostAttachment {
//   id       String  @id @default(uuid())
//   post     Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
//   postId   String
//   url      String
//   mimeType String?
//   order    Int     @default(0)
// }

model Report {
  id         String       @id @default(uuid())
  reporter   User         @relation(fields: [reporterId], references: [id], onDelete: Cascade)
  reporterId String
  // report can reference either a post or a comment
  post       Post?        @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId     String?
  comment    Comment?     @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId  String?
  reason     String
  status     ReportStatus @default(PENDING)
  createdAt  DateTime     @default(now())
}

model PostLike {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  createdAt DateTime @default(now())

  @@unique([userId, postId])
}

model Comment {
  id        String   @id @default(uuid())
  content   String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  reports   Report[]

  @@index([postId, createdAt])
}

model Group {
  id          String    @id @default(uuid())
  name        String    @unique
  description String?
  sports      String[]
  groupType   GroupType @default(AMATEUR)

  acceptingNewMembers Boolean             @default(false)
  verificationRequest Boolean             @default(false)
  verificationStatus  VerificationStatus?

  bio         String?  // Bio do grupo
  logoUrl     String?  // URL do logo no Cloudinary
  bannerUrl   String?  // URL do banner no Cloudinary
  logoId      String?  // Public ID do Cloudinary
  bannerId    String?  // Public ID do Cloudinary

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // relationsships
  joinRequests GroupJoinRequest[]
  posts        Post[]
  memberships  GroupMembership[]
  followers    GroupFollow[]
}

model GroupMembership {
  id        String    @id @default(uuid())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  group     Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId   String
  role      GroupRole @default(MEMBER)
  isCreator Boolean   @default(false) // quem cria automaticamente ganha isCreator=true
  createdAt DateTime  @default(now())

  @@unique([userId, groupId])
}

model GroupJoinRequest {
  id        String            @id @default(uuid())
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  group     Group             @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId   String
  madeBy    MadeBy
  status    JoinRequestStatus @default(PENDING)
  message   String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  @@unique([userId, groupId])
}

model Match {
  id          String  @id @default(uuid())
  title       String
  description String? // descrição (opcional)
  author      User    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId    String

  teamNameA  String? @default("TIME_A") // nome do time A
  teamAScore Int     @default(0)
  teamNameB  String? @default("TIME_B") // nome do time B
  teamBScore Int     @default(0)

  maxPlayers Int // numero max de jogadores
  players    PlayerSubscription[] // jogadores inscritos

  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  MatchDate    DateTime
  MatchStatus  MatchStatus
  reminderSent Boolean     @default(false)
  location     String
  sport        String
}

model PlayerSubscription {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  matchId   String
  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  team      TeamSide
  createdAt DateTime @default(now())

  @@unique([userId, matchId]) // garante que o usuário apenas se inscreva uma vez por partida
}

model UsersNotifyTokens {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String   @unique
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model GroupFollow {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, groupId])
}

model UserFollow {
  id String @id @default(uuid())

  followerId String
  follower User @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)

  followingId String
  following User @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model Notification {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  title   String
  content String
  type    NotificationType

  resourceId   String?
  resourceType String? // "GROUP", "MATCH"

  contentId    String?  // Se for um invite tem o Id dele por exemplo

  readAt    DateTime?
  createdAt DateTime  @default(now())
}

model Avaliation {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  score     Int      @default(5)
  message   String?
  createdAt DateTime @default(now())
}
